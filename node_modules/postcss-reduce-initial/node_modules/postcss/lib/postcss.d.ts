import * as mozilla from 'source-map';

/**
 * @param plugins Can also be included with the Processor#use method.
 * @returns A processor that will apply plugins as CSS processors.
 */
declare function postcss(plugins?: postcss.AcceptedPlugin[]): postcss.Processor;
declare function postcss(...plugins: postcss.AcceptedPlugin[]): postcss.Processor;
declare namespace postcss {
  type AcceptedPlugin = Plugin<any> | Transformer | {
    postcss: TransformCallback | Processor;
  } | Processor;
  /**
   * Creates a PostCSS plugin with a standard API.
   * @param name Plugin name. Same as in name property in package.json. It will
   * be saved in plugin.postcssPlugin property.
   * @param initializer Will receive plugin options and should return functions
   * to modify nodes in input CSS.
   */
  function plugin<T>(name: string, initializer: PluginInitializer<T>): Plugin<T>;
  interface Plugin<T> extends Transformer {
    (opts?: T): Transformer;
    postcss: Transformer;
    process: (css: string | {
      toString(): string;
    } | Result, processOpts?: ProcessOptions, pluginOpts?: T) => LazyResult;
  }
  interface Transformer extends TransformCallback {
    postcssPlugin?: string;
    postcssVersion?: string;
  }
  interface TransformCallback {
    /**
     * @returns A Promise that resolves when all work is complete. May return
     * synchronously, but that style of plugin is only meant for debugging and
     * development. In either case, the resolved or returned value is not used -
     * the "result" is the output.
     */
    (root: Root, result: Result): Promise<any> | any;
  }
  interface PluginInitializer<T> {
    (pluginOptions?: T): Transformer;
  }
  /**
   * Contains helpers for working with vendor prefixes.
   */
  export namespace vendor {
    /**
     * @returns The vendor prefix extracted from the input string.
     */
    function prefix(prop: string): string;
    /**
     * @returns The input string stripped of its vendor prefix.
     */
    function unprefixed(prop: string): string;
  }
  type ParserInput = string | { toString(): string };
  interface Parser {
    (css: ParserInput, opts?: Pick<ProcessOptions, 'map' | 'from'>): Root;
  }
  interface Builder {
    (part: string, node?: Node, type?: 'start' | 'end'): void;
  }
  interface Stringifier {
    (node: Node, builder: Builder): void;
  }
  /**
   * Default function to convert a node tree into a CSS string.
   */
  const stringify: Stringifier;
  /**
   * Parses source CSS.
   * @param css The CSS to parse.
   * @param options
   * @returns {} A new Root node, which contains the source CSS nodes.
   */
  const parse: Parser;
  /**
   * Contains helpers for safely splitting lists of CSS values, preserving
   * parentheses and quotes.
   */
  export namespace list {
    /**
     * Safely splits space-separated values (such as those for background,
     * border-radius and other shorthand properties).
     */
    function space(str: string): string[];
    /**
     * Safely splits comma-separated values (such as those for transition-* and
     * background  properties).
     */
    function comma(str: string): string[];
  }
  /**
   * Creates a new Comment node.
   * @param defaults Properties for the new Comment node.
   * @returns The new node.
   */
  function comment(defaults?: CommentNewProps): Comment;
  /**
   * Creates a new AtRule node.
   * @param defaults Properties for the new AtRule node.
   * @returns The new node.
   */
  function atRule(defaults?: AtRuleNewProps): AtRule;
  /**
   * Creates a new Declaration node.
   * @param defaults Properties for the new Declaration node.
   * @returns The new node.
   */
  function decl(defaults?: DeclarationNewProps): Declaration;
  /**
   * Creates a new Rule node.
   * @param defaults Properties for the new Rule node.
   * @returns The new node.
   */
  function rule(defaults?: RuleNewProps): Rule;
  /**
   * Creates a new Root node.
   * @param defaults Properties for the new Root node.
   * @returns The new node.
   */
  function root(defaults?: object): Root;
  interface SourceMapOptions {
    /**
     * Indicates that the source map should be embedded in the output CSS as a
     * Base64-encoded comment. By default, it is true. But if all previous maps
     * are external, not inline, PostCSS will not embed the map even if you do
     * not set this option.
     *
     * If you have an inline source map, the result.map property will be empty,
     * as the source map will be contained within the text of result.css.
     */
    inline?: boolean;
    /**
     * Source map content from a previous processing step (e.g., Sass compilation).
     * PostCSS will try to read the previous source map automatically (based on comments
     * within the source CSS), but you can use this option to identify it manually.
     * If desired, you can omit the previous map with prev: false.
     */
    prev?: any;
    /**
     * Indicates that PostCSS should set the origin content (e.g., Sass source)
     * of the source map. By default, it is true. But if all previous maps do not
     * contain sources content, PostCSS will also leave it out even if you do not set
     * this option.
     */
    sourcesContent?: boolean;
    /**
     * Indicates that PostCSS should add annotation comments to the CSS. By default,
     * PostCSS will always add a comment with a path to the source map. PostCSS will
     * not add annotations to CSS files that do not contain any comments.
     *
     * By default, PostCSS presumes that you want to save the source map as
     * opts.to + '.map' and will use this path in the annotation comment. A different
     * path can be set by providing a string value for annotation.
     *
     * If you have set inline: true, annotation cannot be disabled.
     */
    annotation?: string | boolean;
    /**
     * Override "from" in map's sources.
     */
    from?: string;
  }
  /**
   * A Processor instance contains plugins to process CSS. Create one
   * Processor  instance, initialize its plugins, and then use that instance
   * on numerous CSS files.
   */
  interface Processor {
    /**
     * Adds a plugin to be used as a CSS processor. Plugins can also be
     * added by passing them as arguments when creating a postcss instance.
     */
    use(plugin: AcceptedPlugin): Processor;
    /**
     * Parses source CSS. Because some plugins can be asynchronous it doesn't
     * make any transformations. Transformations will be applied in LazyResult's
     * methods.
     * @param css Input CSS or any object with toString() method, like a file
     * stream. If a Result instance is passed the processor will take the
     * existing Root parser from it.
     */
    process(css: ParserInput | Result | LazyResult | Root, options?: ProcessOptions): LazyResult;
    /**
     * Contains plugins added to this processor.
     */
    plugins: Plugin<any>[];
    /**
     * Contains the current version of PostCSS (e.g., "4.0.5").
     */
    version: string;
  }
  interface ProcessOptions {
    /**
     * The path of the CSS source file. You should always set "from", because 